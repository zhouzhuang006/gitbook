# 理解J.U.C中ReentrantLock的底层设计



## 什么是死锁

这四个条件同时满足， 就会产生死锁

- 互斥 共享资源X和Y 只能被同一个线程占有
- 占用且等待 线程T1 已经获得了X的占有， 同时等待共享资源Y的时候,不释放共享资源X
- 不可抢占， 其他线程不能强行抢占线程T1占有的资源
- 循环等待 线程T1等待线程T2占有的资源， 线程T2等待线程T1占有的资源

要解决死锁， 我们只能破坏 占用等待、 不可抢占、循环等待 

方法一：

分配资源统一分配，申请



方法二：

tryLock



方法三：





### Thread.join



## ThreadLocal

线程级别的私有存储



### 线程探测

、

## 面试题

阿里云、菜鸟ThreadLocal 原理

- sleep
- join
- wait
- notify
- yiled
- sleep 触发一次切换



java 中能够创建 volatile 数组吗？

可以创建， volatile 对于应用可见， 





- java  的 ++ 是线程安全的吗？

线程安全体现的是 有序性 原子性 可见性

++ 操作无法满足原子性

- 线程什么时候会抛出InterruptedExecption()

t.interrupt() 去中断一个处于阻塞状态下的线程时（join/sleep/wait）

- java  中Runnable  的 Callable 有什么区别

接口， 不带返回值

- 有 T1 / T2 /T3 三个线程， 如何保证顺序

  join

- Java 内存模型是什么？



- 什么是线程安全

有序性 原子性 可见性
















